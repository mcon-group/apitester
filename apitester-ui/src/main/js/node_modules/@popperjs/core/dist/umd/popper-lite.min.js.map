{"version":3,"file":"popper-lite.min.js","sources":["../../src/dom-utils/getBoundingClientRect.js","../../src/dom-utils/getWindow.js","../../src/dom-utils/instanceOf.js","../../src/dom-utils/getNodeName.js","../../src/dom-utils/getComputedStyle.js","../../src/dom-utils/getCompositeRect.js","../../src/dom-utils/getNodeScroll.js","../../src/dom-utils/getHTMLElementScroll.js","../../src/dom-utils/getWindowScroll.js","../../src/dom-utils/getBorders.js","../../src/dom-utils/getParentNode.js","../../src/dom-utils/listScrollParents.js","../../src/dom-utils/getScrollParent.js","../../src/dom-utils/getOffsetParent.js","../../src/dom-utils/isTableElement.js","../../src/utils/orderModifiers.js","../../src/utils/debounce.js","../../src/index.js","../../src/dom-utils/getLayoutRect.js","../../src/modifiers/computeStyles.js","../../src/enums.js","../../src/modifiers/eventListeners.js","../../src/popper-lite.js","../../src/modifiers/popperOffsets.js","../../src/utils/computeOffsets.js","../../src/utils/getBasePlacement.js","../../src/utils/getVariation.js","../../src/utils/getMainAxisFromPlacement.js","../../src/modifiers/applyStyles.js"],"sourcesContent":["// @flow\nimport type { ClientRectObject, VirtualElement } from '../types';\n\nexport default function getBoundingClientRect(\n  element: Element | VirtualElement\n): ClientRectObject {\n  const rect = element.getBoundingClientRect();\n\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top,\n  };\n}\n","// @flow\n\nexport default function getWindow(node: Node): any {\n  if ({}.toString.call(node) !== '[object Window]') {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  return node;\n}\n","// @flow\nimport getWindow from './getWindow';\n\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  const OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement;\n}\n\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\nfunction isHTMLElement(node) {\n  const OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement;\n}\n\nexport { isElement, isHTMLElement };\n","// @flow\n\nexport default function getNodeName(element: ?Node): ?string {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getComputedStyle(\n  element: Element\n): CSSStyleDeclaration {\n  return getWindow(element).getComputedStyle(element);\n}\n","// @flow\nimport type { Rect, VirtualElement, Offsets } from '../types';\nimport getBoundingClientRect from './getBoundingClientRect';\nimport getNodeScroll from './getNodeScroll';\nimport getNodeName from './getNodeName';\nimport getBorders from './getBorders';\nimport { isHTMLElement } from './instanceOf';\n\n// offsets without `border`\nfunction getInnerOffsets(offsetParent: Element): Offsets {\n  const rect = getBoundingClientRect(offsetParent);\n  const borders = getBorders(offsetParent);\n\n  return {\n    x: rect.x + borders.left,\n    y: rect.y + borders.top,\n  };\n}\n\n// Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nexport default function getCompositeRect(\n  elementOrVirtualElement: Element | VirtualElement,\n  offsetParent: Element,\n  isFixed: boolean = false\n): Rect {\n  const rect = getBoundingClientRect(elementOrVirtualElement);\n\n  let scroll = { scrollLeft: 0, scrollTop: 0 };\n  let offsets = { x: 0, y: 0 };\n\n  if (!isFixed) {\n    if (getNodeName(offsetParent) !== 'body') {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getInnerOffsets(offsetParent);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height,\n  };\n}\n","// @flow\nimport getWindowScroll from './getWindowScroll';\nimport getWindow from './getWindow';\nimport { isHTMLElement } from './instanceOf';\nimport getHTMLElementScroll from './getHTMLElementScroll';\n\nexport default function getNodeScroll(node: Node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n","// @flow\n\nexport default function getHTMLElementScroll(element: HTMLElement) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop,\n  };\n}\n","// @flow\nimport getWindow from './getWindow';\n\nexport default function getWindowScroll(node: Node) {\n  const win = getWindow(node);\n  const scrollLeft = win.pageXOffset;\n  const scrollTop = win.pageYOffset;\n\n  return {\n    scrollLeft,\n    scrollTop,\n  };\n}\n","// @flow\nimport type { SideObject } from '../types';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\n\nfunction toNumber(cssValue: string): number {\n  return parseFloat(cssValue) || 0;\n}\n\nexport default function getBorders(element: Element): SideObject {\n  const computedStyle = isHTMLElement(element) ? getComputedStyle(element) : {};\n\n  return {\n    top: toNumber(computedStyle.borderTopWidth),\n    right: toNumber(computedStyle.borderRightWidth),\n    bottom: toNumber(computedStyle.borderBottomWidth),\n    left: toNumber(computedStyle.borderLeftWidth),\n  };\n}\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default function getParentNode(element: Node | ShadowRoot): Node {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    document.ownerDocument || // Fallback to ownerDocument if available\n    document.documentElement // Or to documentElement if everything else fails\n  );\n}\n","// @flow\nimport getScrollParent from './getScrollParent';\nimport getParentNode from './getParentNode';\nimport getNodeName from './getNodeName';\nimport getWindow from './getWindow';\n\nexport default function listScrollParents(\n  element: Node,\n  list: Array<Element> = []\n): Array<Element> {\n  const scrollParent = getScrollParent(element);\n  const isBody = getNodeName(scrollParent) === 'body';\n  const target = isBody ? getWindow(scrollParent) : scrollParent;\n  const updatedList = list.concat(target);\n\n  return isBody\n    ? updatedList\n    : updatedList.concat(listScrollParents(getParentNode(target)));\n}\n","// @flow\nimport getParentNode from './getParentNode';\nimport getComputedStyle from './getComputedStyle';\nimport getNodeName from './getNodeName';\nimport { isHTMLElement } from './instanceOf';\n\nexport default function getScrollParent(node: Node): HTMLElement {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node)) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    const { overflow, overflowX, overflowY } = getComputedStyle(node);\n\n    if (/auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX)) {\n      return node;\n    }\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n","// @flow\nimport getWindow from './getWindow';\nimport getNodeName from './getNodeName';\nimport getComputedStyle from './getComputedStyle';\nimport { isHTMLElement } from './instanceOf';\nimport isTableElement from './isTableElement';\n\n// https://stackoverflow.com/a/9851769/2059996\nconst isFirefox = () => typeof window.InstallTrigger !== 'undefined';\n\nfunction getTrueOffsetParent(element: Element): ?Element {\n  let offsetParent;\n\n  if (\n    !isHTMLElement(element) ||\n    !(offsetParent = element.offsetParent) ||\n    // https://github.com/popperjs/popper.js/issues/837\n    (isFirefox() && getComputedStyle(offsetParent).position === 'fixed')\n  ) {\n    return null;\n  }\n\n  return offsetParent;\n}\n\nexport default function getOffsetParent(element: Element) {\n  const window = getWindow(element);\n\n  let offsetParent = getTrueOffsetParent(element);\n\n  // Find the nearest non-table offsetParent\n  while (offsetParent && isTableElement(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (\n    offsetParent &&\n    getNodeName(offsetParent) === 'body' &&\n    getComputedStyle(offsetParent).position === 'static'\n  ) {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n","// @flow\nimport getNodeName from './getNodeName';\n\nexport default function isTableElement(element: Element): boolean {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n","// @flow\nimport type { Modifier } from '../types';\nimport { modifierPhases } from '../enums';\n\n// source: https://stackoverflow.com/questions/49875255\nfunction order(modifiers) {\n  const map = new Map();\n  const visited = new Set();\n  const result = [];\n\n  modifiers.forEach(modifier => {\n    map.set(modifier.name, modifier);\n  });\n\n  // On visiting object, check for its dependencies and visit them recursively\n  function sort(modifier: Modifier<any>) {\n    visited.add(modifier.name);\n\n    const requires = [\n      ...(modifier.requires || []),\n      ...(modifier.requiresIfExists || []),\n    ];\n\n    requires.forEach(dep => {\n      if (!visited.has(dep)) {\n        const depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n\n    result.push(modifier);\n  }\n\n  modifiers.forEach(modifier => {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n\n  return result;\n}\n\nexport default function orderModifiers(\n  modifiers: Array<Modifier<any>>\n): Array<Modifier<any>> {\n  // order based on dependencies\n  const orderedModifiers = order(modifiers);\n\n  // order based on phase\n  return modifierPhases.reduce((acc, phase) => {\n    return acc.concat(\n      orderedModifiers.filter(modifier => modifier.phase === phase)\n    );\n  }, []);\n}\n","// @flow\n\nexport default function debounce<T>(fn: Function): () => Promise<T> {\n  let pending;\n  return () => {\n    if (!pending) {\n      pending = new Promise<T>(resolve => {\n        Promise.resolve().then(() => {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n","// @flow\nimport type {\n  State,\n  Options,\n  Modifier,\n  Instance,\n  VirtualElement,\n} from './types';\nimport getCompositeRect from './dom-utils/getCompositeRect';\nimport getLayoutRect from './dom-utils/getLayoutRect';\nimport listScrollParents from './dom-utils/listScrollParents';\nimport getOffsetParent from './dom-utils/getOffsetParent';\nimport getComputedStyle from './dom-utils/getComputedStyle';\nimport orderModifiers from './utils/orderModifiers';\nimport debounce from './utils/debounce';\nimport validateModifiers from './utils/validateModifiers';\nimport uniqueBy from './utils/uniqueBy';\nimport getBasePlacement from './utils/getBasePlacement';\nimport { isElement } from './dom-utils/instanceOf';\nimport { auto } from './enums';\n\nexport * from './types';\nexport * from './enums';\n\nconst INVALID_ELEMENT_ERROR =\n  'Popper: Invalid reference or popper argument provided to Popper, they must be either a valid DOM element, virtual element, or a jQuery-wrapped DOM element.';\nconst INFINITE_LOOP_ERROR =\n  'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\n\nconst DEFAULT_OPTIONS: Options = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute',\n};\n\ntype PopperGeneratorArgs = {\n  defaultModifiers?: Array<Modifier<any>>,\n  defaultOptions?: $Shape<Options>,\n};\n\nfunction areValidElements(...args: Array<any>): boolean {\n  return !args.some(\n    element => !(element && typeof element.getBoundingClientRect === 'function')\n  );\n}\n\nexport function popperGenerator(generatorOptions: PopperGeneratorArgs = {}) {\n  const {\n    defaultModifiers = [],\n    defaultOptions = DEFAULT_OPTIONS,\n  } = generatorOptions;\n\n  return function createPopper(\n    reference: Element | VirtualElement,\n    popper: HTMLElement,\n    options: $Shape<Options> = defaultOptions\n  ): Instance {\n    let state: $Shape<State> = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: { ...DEFAULT_OPTIONS, ...defaultOptions },\n      modifiersData: {},\n      elements: {\n        reference,\n        popper,\n      },\n      attributes: {},\n      styles: {},\n    };\n\n    let effectCleanupFns: Array<() => void> = [];\n    let isDestroyed = false;\n\n    const instance = {\n      state,\n      setOptions(options) {\n        cleanupModifierEffects();\n\n        state.options = {\n          ...defaultOptions,\n          ...state.options,\n          ...options,\n        };\n\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : [],\n          popper: listScrollParents(popper),\n        };\n\n        // Orders the modifiers based on their dependencies and `phase`\n        // properties\n        const orderedModifiers = orderModifiers([\n          ...state.options.modifiers.filter(\n            modifier =>\n              !defaultModifiers.find(({ name }) => name === modifier.name)\n          ),\n          ...defaultModifiers.map(defaultModifier => ({\n            ...defaultModifier,\n            ...state.options.modifiers.find(\n              ({ name }) => name === defaultModifier.name\n            ),\n          })),\n        ]);\n\n        // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n        if (__DEV__) {\n          const modifiers = uniqueBy(\n            [...orderedModifiers, ...state.options.modifiers],\n            ({ name }) => name\n          );\n\n          validateModifiers(modifiers);\n\n          if (getBasePlacement(state.options.placement) === auto) {\n            const flipModifier = orderedModifiers.find(\n              ({ name }) => name === 'flip'\n            );\n\n            if (!flipModifier) {\n              console.error(\n                [\n                  'Popper: \"auto\" placements require the \"flip\" modifier be',\n                  'present and enabled to work.',\n                ].join(' ')\n              );\n            }\n          }\n\n          const {\n            marginTop,\n            marginRight,\n            marginBottom,\n            marginLeft,\n          } = getComputedStyle(popper);\n\n          // We no longer take into account `margins` on the popper, and it can\n          // cause bugs with positioning, so we'll warn the consumer\n          if (\n            [marginTop, marginRight, marginBottom, marginLeft].some(margin =>\n              parseFloat(margin)\n            )\n          ) {\n            console.warn(\n              [\n                'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                'between the popper and its reference element or boundary.',\n                'To replicate margin, use the `offset` modifier, as well as',\n                'the `padding` option in the `preventOverflow` and `flip`',\n                'modifiers.',\n              ].join(' ')\n            );\n          }\n        }\n\n        // Strip out disabled modifiers\n        state.orderedModifiers = orderedModifiers.filter(m => m.enabled);\n\n        runModifierEffects();\n\n        return instance.update();\n      },\n\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        const { reference, popper } = state.elements;\n\n        // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n        if (!areValidElements(reference, popper)) {\n          if (__DEV__) {\n            console.error(INVALID_ELEMENT_ERROR);\n          }\n          return;\n        }\n\n        // Store the reference and popper rects to be read by modifiers\n        state.rects = {\n          reference: getCompositeRect(\n            reference,\n            getOffsetParent(popper),\n            state.options.strategy === 'fixed'\n          ),\n          popper: getLayoutRect(popper),\n        };\n\n        // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n        state.reset = false;\n\n        state.placement = state.options.placement;\n\n        // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n        state.orderedModifiers.forEach(\n          modifier =>\n            (state.modifiersData[modifier.name] = {\n              ...modifier.data,\n            })\n        );\n\n        let __debug_loops__ = 0;\n        for (let index = 0; index < state.orderedModifiers.length; index++) {\n          if (__DEV__) {\n            __debug_loops__ += 1;\n            if (__debug_loops__ > 100) {\n              console.error(INFINITE_LOOP_ERROR);\n              break;\n            }\n          }\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          const { fn, options = {}, name } = state.orderedModifiers[index];\n\n          if (typeof fn === 'function') {\n            state = fn({ state, options, name, instance }) || state;\n          }\n        }\n      },\n\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce<$Shape<State>>(\n        () =>\n          new Promise<$Shape<State>>(resolve => {\n            instance.forceUpdate();\n            resolve(state);\n          })\n      ),\n\n      destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      },\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (__DEV__) {\n        console.error(INVALID_ELEMENT_ERROR);\n      }\n      return instance;\n    }\n\n    instance.setOptions(options).then(state => {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    });\n\n    // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(({ name, options = {}, effect }) => {\n        if (typeof effect === 'function') {\n          const cleanupFn = effect({ state, name, instance, options });\n          const noopFn = () => {};\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(fn => fn());\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\n\nexport const createPopper = popperGenerator();\n","// @flow\nimport type { Rect } from '../types';\n\n// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nexport default function getLayoutRect(element: HTMLElement): Rect {\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: element.offsetWidth,\n    height: element.offsetHeight,\n  };\n}\n","// @flow\nimport type {\n  PositioningStrategy,\n  Offsets,\n  Modifier,\n  ModifierArguments,\n  Rect,\n} from '../types';\nimport { type BasePlacement, top, left, right, bottom } from '../enums';\nimport getOffsetParent from '../dom-utils/getOffsetParent';\nimport getWindow from '../dom-utils/getWindow';\nimport getDocumentElement from '../dom-utils/getDocumentElement';\nimport getBasePlacement from '../utils/getBasePlacement';\n\ntype Options = {\n  gpuAcceleration: boolean,\n  adaptive: boolean,\n};\n\nconst unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto',\n};\n\n// Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\nfunction roundOffsets({ x, y }): Offsets {\n  const dpr = window.devicePixelRatio || 1;\n\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0,\n  };\n}\n\nexport function mapToStyles({\n  popper,\n  popperRect,\n  placement,\n  offsets,\n  position,\n  gpuAcceleration,\n  adaptive,\n}: {\n  popper: HTMLElement,\n  popperRect: Rect,\n  placement: BasePlacement,\n  offsets: Offsets,\n  position: PositioningStrategy,\n  gpuAcceleration: boolean,\n  adaptive: boolean,\n}) {\n  let { x, y } = roundOffsets(offsets);\n\n  const hasX = offsets.hasOwnProperty('x');\n  const hasY = offsets.hasOwnProperty('y');\n\n  let sideX: string = left;\n  let sideY: string = top;\n\n  if (adaptive) {\n    let offsetParent = getOffsetParent(popper);\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    }\n\n    if (placement === top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  const commonStyles = {\n    position,\n    ...(adaptive && unsetSides),\n  };\n\n  if (gpuAcceleration) {\n    return {\n      ...commonStyles,\n      [sideY]: hasY ? '0' : '',\n      [sideX]: hasX ? '0' : '',\n      // Layer acceleration can disable subpixel rendering which causes slightly\n      // blurry text on low PPI displays, so we want to use 2D transforms\n      // instead\n      transform:\n        (window.devicePixelRatio || 1) < 2\n          ? `translate(${x}px, ${y}px)`\n          : `translate3d(${x}px, ${y}px, 0)`,\n    };\n  }\n\n  return {\n    ...commonStyles,\n    [sideY]: hasY ? `${y}px` : '',\n    [sideX]: hasX ? `${x}px` : '',\n    transform: '',\n  };\n}\n\nfunction computeStyles({ state, options }: ModifierArguments<Options>) {\n  const { gpuAcceleration = true, adaptive = true } = options;\n\n  const commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration,\n  };\n\n  // popper offsets are always available\n  state.styles.popper = {\n    ...state.styles.popper,\n    ...mapToStyles({\n      ...commonStyles,\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive,\n    }),\n  };\n\n  // arrow offsets may not be available\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = {\n      ...state.styles.arrow,\n      ...mapToStyles({\n        ...commonStyles,\n        offsets: state.modifiersData.arrow,\n        position: 'absolute',\n        adaptive: false,\n      }),\n    };\n  }\n\n  state.attributes.popper = {\n    ...state.attributes.popper,\n    'data-popper-placement': state.placement,\n  };\n}\n\nexport default ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nexport const top: 'top' = 'top';\nexport const bottom: 'bottom' = 'bottom';\nexport const right: 'right' = 'right';\nexport const left: 'left' = 'left';\nexport const auto: 'auto' = 'auto';\nexport type BasePlacement =\n  | typeof top\n  | typeof bottom\n  | typeof right\n  | typeof left;\nexport const basePlacements: Array<BasePlacement> = [top, bottom, right, left];\n\nexport const start: 'start' = 'start';\nexport const end: 'end' = 'end';\nexport type Variation = typeof start | typeof end;\n\nexport const clippingParents: 'clippingParents' = 'clippingParents';\nexport const viewport: 'viewport' = 'viewport';\nexport type Boundary =\n  | HTMLElement\n  | Array<HTMLElement>\n  | typeof clippingParents;\nexport type RootBoundary = typeof viewport | 'document';\n\nexport const popper: 'popper' = 'popper';\nexport const reference: 'reference' = 'reference';\nexport type Context = typeof popper | typeof reference;\n\nexport type VariationPlacement =\n  | 'top-start'\n  | 'top-end'\n  | 'bottom-start'\n  | 'bottom-end'\n  | 'right-start'\n  | 'right-end'\n  | 'left-start'\n  | 'left-end';\nexport type AutoPlacement = 'auto' | 'auto-start' | 'auto-end';\nexport type ComputedPlacement = VariationPlacement | BasePlacement;\nexport type Placement = AutoPlacement | BasePlacement | VariationPlacement;\n\nexport const variationPlacements: Array<VariationPlacement> = basePlacements.reduce(\n  (acc: Array<VariationPlacement>, placement: BasePlacement) =>\n    acc.concat([(`${placement}-${start}`: any), (`${placement}-${end}`: any)]),\n  []\n);\nexport const placements: Array<Placement> = [...basePlacements, auto].reduce(\n  (\n    acc: Array<Placement>,\n    placement: BasePlacement | typeof auto\n  ): Array<Placement> =>\n    acc.concat([\n      placement,\n      (`${placement}-${start}`: any),\n      (`${placement}-${end}`: any),\n    ]),\n  []\n);\n\n// modifiers that need to read the DOM\nexport const beforeRead: 'beforeRead' = 'beforeRead';\nexport const read: 'read' = 'read';\nexport const afterRead: 'afterRead' = 'afterRead';\n// pure-logic modifiers\nexport const beforeMain: 'beforeMain' = 'beforeMain';\nexport const main: 'main' = 'main';\nexport const afterMain: 'afterMain' = 'afterMain';\n// modifier with the purpose to write to the DOM (or write into a framework state)\nexport const beforeWrite: 'beforeWrite' = 'beforeWrite';\nexport const write: 'write' = 'write';\nexport const afterWrite: 'afterWrite' = 'afterWrite';\nexport const modifierPhases: Array<ModifierPhases> = [\n  beforeRead,\n  read,\n  afterRead,\n  beforeMain,\n  main,\n  afterMain,\n  beforeWrite,\n  write,\n  afterWrite,\n];\n\nexport type ModifierPhases =\n  | typeof beforeRead\n  | typeof read\n  | typeof afterRead\n  | typeof beforeMain\n  | typeof main\n  | typeof afterMain\n  | typeof beforeWrite\n  | typeof write\n  | typeof afterWrite;\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport getWindow from '../dom-utils/getWindow';\n\ntype Options = {\n  scroll: boolean,\n  resize: boolean,\n};\n\nconst passive = { passive: true };\n\nfunction effect({ state, instance, options }: ModifierArguments<Options>) {\n  const { scroll = true, resize = true } = options;\n\n  const window = getWindow(state.elements.popper);\n  const scrollParents = [\n    ...state.scrollParents.reference,\n    ...state.scrollParents.popper,\n  ];\n\n  if (scroll) {\n    scrollParents.forEach(scrollParent => {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return () => {\n    if (scroll) {\n      scrollParents.forEach(scrollParent => {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n}\n\nexport default ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: () => {},\n  effect,\n  data: {},\n}: Modifier<Options>);\n","// @flow\nimport { popperGenerator } from './index';\nimport eventListeners from './modifiers/eventListeners';\nimport popperOffsets from './modifiers/popperOffsets';\nimport computeStyles from './modifiers/computeStyles';\nimport applyStyles from './modifiers/applyStyles';\n\nconst defaultModifiers = [\n  eventListeners,\n  popperOffsets,\n  computeStyles,\n  applyStyles,\n];\n\nconst createPopper = popperGenerator({ defaultModifiers });\n\n// eslint-disable-next-line import/no-unused-modules\nexport { createPopper, popperGenerator, defaultModifiers };\n","// @flow\nimport type { ModifierArguments, Modifier } from '../types';\nimport computeOffsets from '../utils/computeOffsets';\n\nfunction popperOffsets({ state, name }: ModifierArguments<{||}>) {\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement,\n  });\n}\n\nexport default ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {},\n}: Modifier<{||}>);\n","// @flow\nimport getBasePlacement from './getBasePlacement';\nimport getVariation from './getVariation';\nimport getMainAxisFromPlacement from './getMainAxisFromPlacement';\nimport type {\n  Rect,\n  PositioningStrategy,\n  Offsets,\n  ClientRectObject,\n} from '../types';\nimport { top, right, bottom, left, start, end, type Placement } from '../enums';\n\nexport default function computeOffsets({\n  reference,\n  element,\n  placement,\n}: {\n  reference: Rect | ClientRectObject,\n  element: Rect | ClientRectObject,\n  strategy: PositioningStrategy,\n  placement?: Placement,\n}): Offsets {\n  const basePlacement = placement ? getBasePlacement(placement) : null;\n  const variation = placement ? getVariation(placement) : null;\n  const commonX = reference.x + reference.width / 2 - element.width / 2;\n  const commonY = reference.y + reference.height / 2 - element.height / 2;\n\n  let offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height,\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height,\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY,\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY,\n      };\n      break;\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y,\n      };\n  }\n\n  const mainAxis = basePlacement\n    ? getMainAxisFromPlacement(basePlacement)\n    : null;\n\n  if (mainAxis != null) {\n    const len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) -\n          Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] =\n          Math.floor(offsets[mainAxis]) +\n          Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n      default:\n    }\n  }\n\n  return offsets;\n}\n","// @flow\nimport { type BasePlacement, type Placement, auto } from '../enums';\n\nexport default function getBasePlacement(\n  placement: Placement | typeof auto\n): BasePlacement {\n  return (placement.split('-')[0]: any);\n}\n","// @flow\nimport { type Variation, type Placement } from '../enums';\n\nexport default function getVariation(placement: Placement): ?Variation {\n  return (placement.split('-')[1]: any);\n}\n","// @flow\nimport type { Placement } from '../enums';\n\nexport default function getMainAxisFromPlacement(\n  placement: Placement\n): 'x' | 'y' {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n","// @flow\nimport type { Modifier, ModifierArguments } from '../types';\nimport getNodeName from '../dom-utils/getNodeName';\nimport { isHTMLElement } from '../dom-utils/instanceOf';\n\n// This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles({ state }: ModifierArguments<{||}>) {\n  Object.keys(state.elements).forEach(name => {\n    const style = state.styles[name] || {};\n\n    const attributes = state.attributes[name] || {};\n    const element = state.elements[name];\n\n    // arrow is optional + virtual elements\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n\n    // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n    Object.assign(element.style, style);\n\n    Object.keys(attributes).forEach(name => {\n      const value = attributes[name];\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect({ state }: ModifierArguments<{||}>) {\n  const initialStyles = {\n    position: 'absolute',\n    left: '0',\n    top: '0',\n    margin: '0',\n  };\n\n  Object.assign(state.elements.popper.style, initialStyles);\n\n  return () => {\n    Object.keys(state.elements).forEach(name => {\n      const element = state.elements[name];\n      const styleProperties = Object.keys(\n        state.styles.hasOwnProperty(name)\n          ? { ...state.styles[name] }\n          : initialStyles\n      );\n      const attributes = state.attributes[name] || {};\n\n      // Set all values to an empty string to unset them\n      const style = styleProperties.reduce(\n        (style, property) => ({\n          ...style,\n          [String(property)]: '',\n        }),\n        {}\n      );\n\n      // arrow is optional + virtual elements\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n      Object.assign(element.style, style);\n\n      Object.keys(attributes).forEach(attribute =>\n        element.removeAttribute(attribute)\n      );\n    });\n  };\n}\n\nexport default ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect,\n  requires: ['computeStyles'],\n}: Modifier<{||}>);\n"],"names":["getBoundingClientRect","element","width","rect","height","top","right","bottom","left","x","y","getWindow","node","ownerDocument","window","isElement","isHTMLElement","getNodeName","getComputedStyle","getCompositeRect","elementOrVirtualElement","offsetParent","isFixed","scroll","scrollLeft","scrollTop","e","d","getHTMLElementScroll","win","getWindowScroll","computedStyle","parseFloat","borders","offsets","getParentNode","document","listScrollParents","list","scrollParent","getScrollParent","isBody","target","updatedList","getTrueOffsetParent","getOffsetParent","order","modifiers","map","Map","visited","Set","result","modifier","dep","depModifier","sort","debounce","fn","pending","Promise","resolve","undefined","areValidElements","args","popperGenerator","generatorOptions","defaultModifiers","defaultOptions","DEFAULT_OPTIONS","reference","popper","options","effectCleanupFns","state","placement","orderedModifiers","modifiersData","elements","attributes","styles","isDestroyed","instance","setOptions","cleanupModifierEffects","orderModifiers","acc","phase","defaultModifier","m","name","cleanupFn","effect","noopFn","forceUpdate","index","update","destroy","mapToStyles","popperRect","position","gpuAcceleration","adaptive","dpr","Math","hasX","sideX","sideY","commonStyles","unsetSides","hasY","modifierPhases","strategy","passive","eventListeners","enabled","resize","scrollParents","data","popperOffsets$1","popperOffsets","basePlacement","commonX","commonY","mainAxis","len","variation","start","end","computeStyles$1","computeStyles","applyStyles$1","applyStyles","style","Object","value","effect$1","initialStyles","margin","styleProperties","property","String","attribute","requires","createPopper"],"mappings":"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"}